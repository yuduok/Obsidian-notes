# HTTP HTTPS

## HTTP

超文本传输协议，是实现网络通信的一种规范

- 支持客户/服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- 无状态：HTTP协议无法根据之前的状态进行本次的请求处理

## HTTPS

http传递信息是明文传输，https出现是为了解决其不安全的特性

1. **客户端发起请求**：客户端（如浏览器）向服务器发起 HTTPS 请求。
2. **服务器响应并发送证书**：服务器响应请求，并将 SSL/TLS 证书发送给客户端。证书中包含服务器的公钥和由证书颁发机构（CA）签名的信息。
3. **客户端验证证书**：客户端验证服务器证书的有效性，检查证书是否由受信任的 CA 签发，证书是否过期等。
4. **协商加密方式**：客户端和服务器协商使用的加密算法和会话密钥（对称加密密钥）。
5. **建立安全连接**：使用协商好的加密方式和会话密钥，客户端和服务器之间建立安全的加密连接。
6. **数据传输**：在加密连接上进行数据传输，确保数据的保密性和完整性。

# HTTPS是如何保证安全的

在采用`SSL`后，`HTTP`就拥有了`HTTPS`的加密、证书和完整性保护这些功能

> SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议

## SSL

`SSL`的实现这些功能主要依赖于三种手段：

- 对称加密：采用协商的密钥对数据加密
- 非对称加密：实现身份认证和密钥协商
- 摘要算法：验证信息的完整性
- 数字签名：身份验证

# UDP和TCP

## UDP

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- 传输途中出现丢包，UDP 也不负责重发
- 当包的到达顺序出现乱序时，UDP没有纠正的功能。
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

## TCP

- TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）

# TCP/IP协议

划分为

- 应用层
- 传输层
- 网络层
- 链路层

# DNS

简单来讲，`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

## 查询方式

- 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案
- 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求

## 查询过程

解析域名的过程如下：

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

# CDN

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

## 原理

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

# HTTP 1.0/1.1/2.0

## 1.0

每次请求都需要建立tcp连接

## 1.1

默认支持长连接

同时，`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间

## 2.0

### 多路复用

`HTTP/2` 复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”

将每个请求和响应映射到一个流，每个流都有自己的唯一标识符

### 分帧

帧是`HTTP2`通信中最小单位信息

`HTTP/2` 采用二进制格式传输数据，而非 `HTTP 1.x`的文本格式，解析起来更高效

# HTTP状态码

## 1xx 信息状态码

- 100 客户端应继续其请求
- 101 服务器根据客户端请求切换协议

## 2xx 成功状态码

- **200 OK**：请求成功，服务器已成功处理请求。
- **201 Created**：请求成功并且服务器创建了新的资源。
- **202 Accepted**：请求已接受，但尚未处理。
- **204 No Content**：服务器成功处理了请求，但没有返回任何内容。

## 3xx 重定向状态码

- **301 Moved Permanently**：请求的资源已永久移动到新的 URL。
- **302 Found**：请求的资源临时移动到新的 URL。
- **303 See Other**：请求的资源可以在另一个 URL 处找到。
- **304 Not Modified**：请求的资源未修改，客户端可以使用缓存的版本。

## 4xx 客户端错误状态码

- **400 Bad Request**：请求无效或格式错误。
- **401 Unauthorized**：请求需要身份验证。
- **403 Forbidden**：服务器拒绝请求，客户端无权访问资源。
- **404 Not Found**：请求的资源未找到。
- **405 Method Not Allowed**：请求方法不被允许。
- **408 Request Timeout**：请求超时。

## 5xx 服务器错误状态码

- **500 Internal Server Error**：服务器内部错误。
- **501 Not Implemented**：服务器不支持请求的方法。
- **502 Bad Gateway**：服务器作为网关或代理，从上游服务器收到无效响应。
- **503 Service Unavailable**：服务器暂时无法处理请求，通常是由于过载或维护。
- **504 Gateway Timeout**：服务器作为网关或代理，未能及时从上游服务器获得响应。

# 输入url到敲下回车发生了什么

- URL解析：首先判断是否是一个合法的url（结构解析，协议、域名、端口、路径、请求体）
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

# TCP

## 三次握手

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

## 四次挥手

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

# websocket

位于应用层

## 特点

1. **全双工通信**：WebSocket 允许客户端和服务器之间的双向通信，这意味着双方都可以独立地发送和接收数据，而无需等待对方的响应。
2. **低延迟**：由于 WebSocket 连接是持久的，减少了传统 HTTP 请求中的握手和头部信息，降低了通信延迟。
3. **高效传输**：WebSocket 连接建立后，数据帧的开销较小，适合频繁的小数据包传输。
4. **状态保持**：WebSocket 连接是持久的，适用于需要保持会话状态的应用场景。