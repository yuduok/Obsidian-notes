# nextjs router

**在app根目录下**

    自动检索page.js文件，作为当前路由下的默认路径

    例如app/page.js 则访问则为/

    app/posts/page.js 则访问/posts

    app/posts/other.js 则访问/posts/other

    同时nextjs支持动态路由

**Link**
    
以app为根目录 切换路由

```js
<Link href="/posts">
    posts //切换至/posts页
</Link>
```

# asset
例如一些svg，icon等存放在public文件夹下，img等标签自动索引该根目录下的资源

for example

app根目录下有 **/public/favicon.icon**, **/public/next.svg**, **/public/other/eg.png**
```js
<img src='/next.svg'/>//public/favicon.icon
<img src='/next.svg'/>//public/next.svg
<img src='/other/eg.png'/>//public/other/eg.png
```

# metadata

针对SEO，为了提高网站的曝光度，可以为每个页面设置一个metadata，可以在浏览器控制台看到相关的数据（title  description etc）

```js
export const metadata =  {
  title:'......';
  description:'......';
}
```

防止对网页的描述多次声明，可以使用template来规避

*app/layout.js*
```js
export const metadata ={
  title:{
    default:'...',
    template:"%s | Nextjs 14"
  },
  description:'...'
}
```

而后在每个页面的title描述后都会看到|Nextjs 14

同时，这种方法也适合传值,例如在下面，我想在title加上当前博客页的标题

*app/blog/[slug]/page.js*
```js
export const generateMetadata = async ({params})=>{
    const {slug} = params;
    const post = await getPost(slug);

    return{
      title:post.title,
      description:post.desc
    }
}

```

# css module

可以在根目录创建一个文件夹放置css样式

如果要使用css module，css文件后缀名必须为 **.module.css**

**eg.**  

*layout.module.css*

```css
.container {
    max-width: 36rem;
    padding: 0 1rem;
    margin: 3rem auto 6rem;
  }
```

*layout.js*
```js
import styles from './layout.module.css'

export default function Layout({ children }) {
    return(
        <div className={styles.container}>
            {children}
        </div>
    );
}
```

由于css module会为每个元素生成特殊类名，所以不会有 ***类名冲突*** 问题

# globals.css
css module适用于组件级的css样式 而在 ***/app/globals.css*** 中可以定义全局页面样式，在 ***/app/layout.js*** 中import使用

*/app/layout.js*
```js
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

# dynamic router
[id]文件夹下创建page.js匹配动态路由

可以在组件中加入参数获取[id]值

eg. current file path /app/blog/[slug]/page.js
```js
const Page = ({params})=>{
  console.log(params) //if url is /app/blog/post then terminal console {slug:'post'}
  return(
    <div>
      example
    </div>
  )
}
```

# layout.js
改变 ***/app/layout.js*** 会改变每个页面的样式 

也可以在当前文件夹下创建layout.js 
```js
const LoginPage = ({children}) => {
  return (
    <div>
      <h1>About Page</h1>
      {children}
    </div>
  );
};
//当前文件下的子组件都生效
export default LoginPage;
```

# error.js
写在当前文件夹下，发生错误时显示

# loading.js
加载时显示

# not-found.js
找不到页面（抛出404错误时）显示

# navigation active or not
使用css module 和react特性，判断当前path下是否为导航页

**eg.**

*navLink.js*
```js
"use client" //usePathname 要在客户端侧
import { usePathname } from 'next/navigation';
import styles from './navLink.module.css'
import Link from 'next/link';

const NavLink = ({item}) => {
    const pathName = usePathname();

    return (//判断是否active
        <Link href={item.path} className={`${styles.container}
        ${pathName === item.path && styles.active}`}>
            {item.title}
        </Link>
    )
}

export default NavLink;
```

*navLink.module.css*
```css
.container{
    min-width: 100px;
    padding: 0;
    border-radius: 20px;
    font-weight: 500;
    text-align: center;
}

.active{
    background-color: var(--text);
    color: var(--bg);
}
```

# Image

*usage*
```js
import Image from 'next/image'

const Img = ()=>{
  return (
    //a.png inside public folder
    //two options should be passed 
    <div>
      <Image src='/a.png' alt='a' 
      width={500} height={500}/>
    </div>
  )
}
```

使用Image而不是img，可以不直接加载图片而是 ***cache***缓存，可以使得页面更加流畅，优化体验

为了适配在各个设备下的使用体验，可以使用fill适应，nextjs会自动更新图片的大小

use ***fill***

*img.module.css
```css
.imgContainer{
  position:relative;
  width:100px;
  height:100px;
}
```

*img.js*
```js
import Image from 'next/image'
import styles from './img.module.css'

const Img = ()=>{
  return (
    //a.png inside public folder
    //two options should be passed 
    <div>
      <div className={styles.imgContainer}>
        <Image src='/a.png' alt='a' fill/>
      </div>
    </div>
  )
}
```
***externel image***

使用Image时，nextjs默认不允许使用外部网页图片，但是可以通过修改 **next.config.mjs** 实现

*next.config.js*
```js
/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        domains: ["example.com"],
    },
};

export default nextConfig;
```

# SSR CSR

nextjs默认使用ssr，它会先将页面交给服务端render，csr也会先将页面交给server，但是首先加载的是 **all js** 然后再产生页面

若想在nextjs使用csr，需要在组件顶端申明"use client"，但在使用客户端组件时可能会遇到一些问题例如 **hydration**

eg. 在一个use client的nextjs组件中
```js
"use client"
const a = Math.random()
console.log(a)
const Blog()=>{
  return(
    <div>{a}</div>
  )
}
export default Blog;
```
因为nextjs仍然会先将页面传给server，所以在terminal会输出一个a的值，而在客户端（浏览器console）中也会输出一个值，需要注意的是，两边的执行并不相同，所以两个a的值也不会相同

如果要解决这个问题，可以使用 ***dynamic*** 解决

eg.一个客户端组件
```js
"use client"

const a = Math.random()
console.log(a)
const NoSSR()=>{
  return(
    <div>{a}</div>
  )
}
export default NoSSR
```

eg.一个服务端组件
```js
import dynamic from "next/dynamic";

const NoSSR = dynamic(()=>import("path of client component") , {ssr:false});

export default function TestPage(){
  return(
    <div>
      <NoSSR>
    </div>
  )
}
```

# useRouter usePathname useSearchParams

使用useRouter可以切换路由
```js
"use client"
import {useRouter} from 'next/navigation'
const router = useRouter()
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

使用usePathname可以获取当前路径名
```js
'use client'
 
import { usePathname } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const pathname = usePathname()
  return <p>Current pathname: {pathname}</p>
}
```
return value eg.

    URL	                Returned value
    /	                  '/'
    /dashboard	          '/dashboard'
    /dashboard?v=2	      '/dashboard'
    /blog/hello-world	  '/blog/hello-world'

使用useSearchParams可以获取参数值

```js
'use client'
 
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')
 
  // URL -> `/dashboard?search=my-project`
  // `search` -> 'my-project'
  return <>Search: {search}</>
}
```

# Suspense

*eg*

```js
<Suspense fallback={<div>Loading...</div>}>
  <PostUser userId={post.userId} />
</Suspense>
```

# jsonPlaceholder

https://jsonplaceholder.typicode.com/

{JSON} Placeholder
Free fake and reliable API for testing and prototyping.

该方法为使用api的方式

JSONPlaceholder comes with a set of 6 common resources:

    /posts	100 posts
    /comments	500 comments
    /albums	100 albums
    /photos	5000 photos
    /todos	200 todos
    /users	10 users

All HTTP methods are supported. You can use http or https for your requests.

    GET	/posts
    GET	/posts/1
    GET	/posts/1/comments
    GET	/comments?postId=1
    POST	/posts
    PUT	/posts/1
    PATCH	/posts/1
    DELETE	/posts/1



当组件PostUser在加载时，Suspense会显示loading

# mongodb

***fetch data without api***

https://cloud.mongodb.com/  使用atlas进行可视化管理，配合mongoosejs使用

创建cloud mongo后，获取自己的连接密钥，可存进环境变量中使用

```env
MONGO = ........
```

models.js  在这定义一些基本数据 例如Post User 格式
```js
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
    username:{
        type:String,
        required:true,
        unique:true,
        min:3,
        max:20
    },
    email:{
        type:String,
        required:true,
        unique:true,
        max:50
    },
    password:{
        type:String,
        required:true,
        min:6
    },
    img:{
        type:String,
    },
    isAdmin:{
        type:Boolean,
        default:false
    }
},{timestamps:true});

const postSchema = new mongoose.Schema({
    title:{
        type:String,
        required:true,
    },
    desc:{
        type:String,
        required:true,
    },
    img:{
        type:String,
    },
    userId:{
        type:String,
        required:true
    },
    slug:{
        type:String,
        required:true,
        unique:true
    }
},{timestamps:true});//当数据库更新时也更新

export const User =  mongoose.models.User || mongoose.model('User',userSchema);//已有就使用前者，不存在就创建一个
export const Post =  mongoose.models.Post || mongoose.model('Post',postSchema);
```

utils 链接数据库
```js
const {default:mongoose} = require('mongoose');

const connection ={}

export const connectToDb = async () => {
    try{
        if(connection.isConnected){
            console.log('Using existing connection')//已连接则直接退出
            return
        }
        const db = await mongoose.connect(process.env.MONGO)
        connection.isConnected = db.connections[0].readyState;//未连接则通过个人的key链接云数据库
    }
    catch(error){
        console.log(error)
        throw new Error(error)
    }
}
```

data.js 在这定义函数从数据库获取数据 **eg.** 以post为例
```js
import { Post } from "./models"
import { connectToDb } from "./utils"

export const getPosts = async ()=>{
    try{
        connectToDb();
        const posts = await Post.find()//找到所有post，返回的是一个数组
        return posts;
    }catch(err){
        console.error(err)
        throw new Error("failed to fetch posts")
    }
}

export const getPost = async (slug)=>{
    try{
        connectToDb();
        const post = await Post.findOne({slug})//通过slug对象查找，返回一个对象
        return post;
    }catch(err){
        console.error(err)
        throw new Error("failed to fetch post")
    }
}
```

**注意** mongodb在创建一条数据时，会为该数据自动生成_id键，也可以通过查询该_id来获取数据,使用的方法为findById()

# unstable_noStore

对于不想进行缓存的数据，可以使用 **unstable_noStore** 来取消缓存

**eg.**

```js
import {unstable_noStore as noStore} from 'next/cache'

export const getPosts = async ()=>{
    noStore();
    try{
        connectToDb();
        const posts = await Post.find()//找到所有post，返回的是一个数组
        return posts;
    }catch(err){
        console.error(err)
        throw new Error("failed to fetch posts")
    }
}
```

# server action

server action表示服务器端事件，可以在单函数内部声明"use server"或者整个组件顶端声明

*app/serverActionTest/page.js*
```js
import { addPost } from "@/lib/action"

const ServerActionTestPage = () => {
    return (
      //表单绑定addPost，传值时会将表单数据上传
        <div>
            <form action={addPost}>
                <input type="text" name="title" placeholder="title"/>
                <input type="text" name="desc"  placeholder="desc"/>
                <input type="text" name="slug"  placeholder="slug"/>
                <input type="text" name="userId"placeholder="userId" />
                <button type="submit">Create</button>
            </form>
        </div>
    );
}

export default ServerActionTestPage;
```


*action.js*
```js
"use server"
import { connectToDb } from "./utils"
import { Post } from "./models"
import { revalidatePath } from "next/cache"

export const addPost =async(formData)=>{
    
    const {title,desc,slug,userId} = Object.fromEntries(formData)//get data from data
    try{
        connectToDb();
        const newPost = new Post({
            title,
            desc,
            slug,
            userId
        });

        await newPost.save();
        revalidatePath('/blog')//等待新数据在数据库保存完成，刷新该页面
    }catch(err){
        console.log(err)
        return {error:'Something went wrong!'}
    }
}
```
