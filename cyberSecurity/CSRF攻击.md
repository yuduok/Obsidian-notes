Cross-Site-Request-Forgery跨站请求伪造

- 跨站点的请求
- 请求是伪造的

用户的浏览器被迫向目标站点发起伪造的请求，这个过程会带上用户的身份验证标识（session、cookie等）以通过目标站点验证，从而借用用户在目标站点的权限进行一系列不被期望的操作。即**借刀杀人**

## Cookie和Session

### Cookie

由于http是**无状态**的，cookie诞生最初是为了**存储web中的状态信息**，每次http请求都会发送Cookie给服务端：Set-Cookie字段

### Session

Session是**服务端使用的一种记录客户端状态的机制**

### 二者区别

1. Cookie通过在客户端记录信息确定用户身份
2. Cookie不安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗
3. Session会在一定时间保存在服务器，访问增多时，会占用服务器性能，为了缓解，适当使用Cookie
4. 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，而Session没有这个限制
## CSRF攻击的原理

1. **受害者登录可信网站A**：用户在浏览器中登录了受信任的网站A，并获得了有效的会话Cookie。

2. **攻击者诱导受害者访问恶意网站B**：攻击者通过电子邮件、即时消息、社交媒体等方式，诱导用户访问包含恶意请求的网页。

3. **恶意网站发送伪造请求**：当用户访问恶意网站B时，该网站在后台自动向可信网站A发送一个请求。由于此前用户已经登录了网站A，浏览器会在请求中自动携带Cookie等认证信息。

4. **可信网站A执行请求**：网站A收到请求后，认为这是用户的正常操作，因而执行了相应的动作，如修改用户信息、进行交易等。

## CSRF攻击的危害

- **未授权操作**：攻击者可以未经授权执行转账、修改信息、删除数据等操作。

- **隐私泄露**：用户的个人信息可能被修改或泄露。

- **系统完整性受损**：攻击者可能利用CSRF漏洞对系统进行破坏，影响系统的完整性和可靠性。

## 防御CSRF攻击的方法

1. **使用CSRF令牌（Token）**：

   - 在表单中加入随机生成的令牌，服务器在接收到请求时校验令牌的有效性。
   - 令牌应与用户的会话绑定，且具有一定的时效性。

2. **验证Referer字段**：

   - 服务器检查请求头中的Referer字段，确保请求来源于可信任的域名。
   - 注意，有些情况下Referer可能为空或被伪造，需谨慎使用。

3. **使用SameSite Cookie属性**：

   - 将Cookie的SameSite属性设置为Strict或Lax，限制第三方网站携带Cookie。
   - 需要注意浏览器的兼容性和正确配置。

4. **避免使用GET请求修改数据**：

   - 确保对服务器数据有修改操作的请求都使用POST或其他非GET方法。
   - GET请求应只用于获取数据，且不对服务器状态进行改变。

5. **双重提交Cookie**：

   - 将CSRF令牌以Cookie的形式发送给客户端，同时在请求中以参数形式提交，服务器校验两者是否一致。

6. **提高用户安全意识**：

   - 教育用户不点击来路不明的链接，不访问不可信的网站。